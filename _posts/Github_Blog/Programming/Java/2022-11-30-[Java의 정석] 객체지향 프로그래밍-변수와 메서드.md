---
title: "[Java의 정석] 객체지향 프로그래밍 - 변수와 메서드"
categories:
  - java
tags:
  - Java의 정석
toc_label: "목차"
toc: true
toc_sticky: true
date: 2022-11-30
---

<details><summary><b>reference</b></summary>
&lt;Java의 정석 3rd Edition&gt;을 학습하고 정리한 내용입니다.
</details>

<b>

# 1. 선언위치에 따른 변수의 종류

변수의 종류를 결정짓는 중요한 요소는 **변수의 선언된 위치**이다. 

- **변수의 종류** : 클래스 변수, 인스턴스 변수, 지역변수

<script src="https://gist.github.com/1eejisoo/2b0894aca46a2511fa1ae10572b29958.js"></script>

멤버변수를 제외한 나머지 변수들은 모두 지역변수이며, 멤버변수 중 `static` 키워드가 붙은 것은 클래스 변수, 붙지 않은 것은 인스턴스 변수이다.

## 인스턴스 변수 (instance variable)

- 클래스 영역에 선언된다.
- 클래스의 인스턴스를 생성할 때 만들어진다.
- 인스턴스 변수의 값을 읽어 오거나 저장하기 위해서는 먼저 인스턴스를 생성해야 한다.
- 인스턴스는 독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 있다.
- 인스턴스마다 고유한 상태를 유지해야하는 속성의 경우, 인스턴스 변수로 선언한다.

## 클래스 변수 (class variable)

- 선언 방법은 인스턴스 변수 앞에 `static` 키워드만 붙이면 된다.
- 인스턴스 변수와 달리, 모든 인스턴스가 공통된 저장공간(변수)을 공유하므로 항상 공통된 값을 갖는다.
- 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우, 클래스 변수로 선언한다.
- 인스턴스 변수와 달리, 인스턴스를 생성하지 않고도 `클래스 이름.클래스 변수`와 같은 형태로 사용할 수 있다. 
- 클래스가 메모리에 로딩될  때 생성되어 프로그램 종료시 까지 유지된다.
- `public` 키워드를 붙이면 같은 프로그램 내에서 어디서나 접근할 수 있는 **전역 변수**(global variable)의 성격을 갖는다.

## 지역 변수 (local variable)

- 메서드 내에 선언되어 메서드 내에서만 사용 가능하다.
- 메서드가 종료되면 소멸되어 사용할 수 없게 된다.
- `for`문 또는 `while`문의 블럭 내에 선언된 지역변수는, 지역변수가 선언된 블럭 {} 내에서만 사용 가능하다.
  - 블럭 {}을 벗어나면 소멸되어 사용할 수 없게 된다.

<br>

<br>

# 2. 클래스 변수와 인스턴스 변수

클래스 변수와 인스턴스 변수의 설명만으로는 완벽히 이해가 되지 않는다. 둘의 차이를 이해하기 위한 예로 카드 게임에 사용되는 카드를 클래스로 정의해보자.

<u>카드의 속성 중 몇 가지로 무늬, 숫자, 폭, 높이가 있다. 무늬와 숫자는 카드마다 다르다. 그러나 폭과 높이는 모든 카드마다 동일하다.</u>

Card 인스턴스는 자신만의 무늬(kind)와 숫자(number)를 유지하고 있어야 하므로 인스턴스 변수로 선언하고, 또한 각 카드의 폭(width)과 높이(height)는 모든 인스턴스가 공통적으로 같은 값을 유지해야하므로 클래스 변수로 선언하는 것이 바람직하다.

아래의 코드를 살펴보자.

<script src="https://gist.github.com/1eejisoo/8847accb4644f766a27da9bc223e349f.js"></script>

**실행결과**

```
Card.width = 100
Card.height = 250
c1은 Heart, 7이며, 크기는 (100, 250)
c2은 Spade, 4이며, 크기는 (100, 250)
c1의 width와 height를 각각 50, 80으로 변경합니다.
c1은 Heart, 7이며, 크기는 (50, 80)
c2은 Spade, 4이며, 크기는 (50, 80)
```

Card 인스턴스인 c1과 c2는 클래스 변수인 width와 height를 공유하기 때문에, c1의 width와 height를 변경하면 c2의 width와 height 값도 바뀐 것과 같은 결과를 얻는다. 

결론적으로 `Card.width`, `c1.width`, `c2.width`는 모두 같은 저장공간을 참조하므로 항상 같은 값을 갖는다.

<br>

## 💡 클래스 변수의 바람직한 사용 형태

그러나 클래스 변수를 사용할 때는 `Card.width`와 같이 `클래스 이름.클래스 변수`의 형태로 사용하는 것이 바람직하다.

`참조변수.클래스 변수`의 형태로도 사용할 수 있지만 이렇게 하면 클래스 변수를 인스턴스 변수로 오해하기 쉽기 때문이다.

<img width="907" alt="스크린샷 2022-11-30 오전 5 02 31" src="https://user-images.githubusercontent.com/93996283/204636182-30875d0a-35fd-4668-8f45-a05901a5e965.png">

실제로 Intellij에서도 `참조변수.클래스 변수`의 형태는 지양하는 것을 권장하고 있다.

<br>

<br>

# 3. 메서드

- `메서드(method)` : **특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것**이다. 수학의  **함수**와 유사하다.[^1]

메서드는 그저 작업을 수행하는데 필요한 값만 넣고 원하는 결과를 얻으면 될 뿐, 메서드가 내부적으로 어떤 과정을 거쳐 결과를 만들어내는지는 전혀 몰라도 된다. <u><b>즉 메서드에 넣을 값(입력)과 반환하는 결과(출력)만 알면 되는 것이다.</b></u> 그래서 메서드를 내부가 보이지 않는 **블랙박스(black box)**라고도 한다.

<br>

## 💡 메서드를 사용하는 이유

**1. 높은 재사용성(reusability)**

한번 만들어 놓은 메서드는 몇 번이고 호출할 수 있으며, 다른 프로그램에서도 사용이 가능하다.

**2. 중복된 코드의 제거**

프로그램을 작성하다보면, 같은 내용의 문장들이 여러 곳에 반복해서 나타나곤 한다. 이렇게 반복되는 문장들을 묶어서 하나의 메서드로 작성해 놓으면, 반복되는 문장들 대신 메서드를 호출하는 한 문장으로 대체할 수 있다. 

그렇게 되면 전체 소스 코드의 길이도 짧아지고, 변경 사항이 발생했을 때 수정해야할 코드의 양이 줄어들어 오류 발생 가능성도 함께 줄어든다. 

**3. 프로그램의 구조화**

큰 규모의 프로그램에서는 문장들을 작업 단위로 나눠서 여러 개의 메서드에 담아 프로그램의 구조를 단순화 시키는 것이 필수적이다. 

<br>**메서드를 사용했을 때의 장점을 예시로 살펴보자.** 

아래 코드는 <u>(1) 배열을 랜덤 값으로 초기화한 후 출력하고</u> <u>(2) 오름차순으로 정렬한 후</u> <u>(3) 단계 별로 배열을 출력하기</u> 정도의 기능을 가지고 있다. 현재는 main 함수 내에 모든 기능이 작성되어있는 상태이다.

 <script src="https://gist.github.com/1eejisoo/211a617315d298c7b643ec17d7b9bc15.js"></script>

현재는 비교적 코드가 짧기 때문에 불편하다고 생각하지 못할 수 있다. 그러나  몇 천 줄, 몇 만 줄이 넘어가는 프로그램에서는 위와 같은 방식으로 작성했다고 생각하면 불편함을 체감할 수 있을 것이다. 

그렇다면 메서드를 이용해 작업 단위 별로 분리해보자.

<script src="https://gist.github.com/1eejisoo/6c1c708677a070eccf428a67ec1380e9.js"></script>

이처럼 main 메서드는 프로그램의 전체 흐름이 한눈에 들어올 정도로 단순하게 구조화하는 것이 좋다. 그래야 나중에 프로그램에 문제가 발생해도 해당 부분을 쉽게 찾아서 해결할 수 있다.

처음부터 작업 단위 별로 나누어 프로그램을 설계하는 것은 쉽지 않다. 그렇기 때문에 처음에 프로그램을 설계할 때에는 내용이 없는 메서드를 작업 단위로 만들어 놓고, 하나씩 완성해가는 것도 프로그램을 구조화하는 좋은 방법이다.

<br>

<br>

# 4. JVM의 메모리 구조

응용 프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고, 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다. 그 중 **3가지 주요 영역(Method Area, Call stack, Heap)**에 대해 알아보자.

<img width="763" alt="스크린샷 2022-11-30 오후 6 58 58" src="https://user-images.githubusercontent.com/93996283/204765895-433c405c-94ee-4dcc-a1a2-229a6f2bfad0.png">

**1. 메서드 영역 (Method Area)**

- 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스 파일 (*.class)을 읽고 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다.
- 이때, 그 클래스의 클래스변수(class variable)도 이 영역에 함께 생성된다.

**2. 힙 (Heap)**

- 인스턴스가 생성되는 공간. 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다.
- 즉, 인스턴스 변수(instance variable)들이 생성되는 공간이다.

**3. 호출스택 (Call stack 또는 Execution stack)**

- 메서드의 작업에 필요한 메모리 공간을 제공한다.
- 메서드가 호출되면 메서드를 위한 메모리가 호출스택에 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수 (매개변수 포함)들과 연산의 중간 결과 등을 저장하는데 사용된다.
- 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.
- 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.
- 메서드가 작업을 마치면 할당되었던 메모리 공간은 반환되어 비워진다.

<br>

<br>

# 5. 기본형 매개변수와 참조형 매개변수

자바에서는 메서드를 호출할 때 매개변수로 지정한 값을 메서드의 매개변수에 복사해서 넘겨준다. 매개변수의 타입이 기본형(primitive type)일 때는 **기본형 값이 복사**되겠지만, 참조형(reference type)이면 **인스턴스의 주소가 복사**된다. 

- `기본형 매개변수` : 변수의 값을 읽기만 할 수 있다. *(read only)*
- `참조형 매개변수` : 변수의 값을 읽고 변경할 수 있다. *(read & write)*

## 기본형 매개변수

<script src="https://gist.github.com/1eejisoo/cf17e8ea81c73159cee54de5a2fd7bb0.js"></script>

**실행결과**

```
main() : x = 10
change() : x = 1000
After change(d.x)
main() : x = 10
```

line19의 `change(d.x);`를 수행하였음에도 main 메서드에서는 d.x의 값이 그대로이다. 왜 이런 결과가 나오는 것일까?

답은 **'d.x'의 값이 변경된 것이 아니라, change 메서드의 매개변수 x의 값이 변경된 것**이기 때문이다. 단계별로 살펴보자.

1. change 메서드가 호출되면서 'd.x'가 change 메서드의 매개변수 x에 복사된다.

2. change 메서드에서는 x = 1000으로 값을 변경한다. 
3. change 메서드가 종료되면서 매개변수 x는 스택에서 제거된다.

 즉, 원본이 아닌 복사본이 변경된 것이라 원본에는 아무런 영향을 미치지 못한다.

<br>

## 참조형 매개변수

<script src="https://gist.github.com/1eejisoo/99b00a13a5d7c8077c93b9c298289591.js"></script>

**실행결과**

```
main() : x = 10
change() : x = 1000
After change(d)
main() : x = 1000
```

기본형 매개변수와는 다르게 change 메서드를 호출한 후에 'd.x'의 값이 변경되었다. **값이 아니라 저장된 주소**를 change 메서드에게 넘겨주었기 때문에 값을 읽어오는 것뿐만 아니라 변경하는 것도 가능하다. 단계별로 살펴보자.

1. change 메서드가 호출되면서 참조변수 **d의 값(주소)**이 매개변수d에 복사된다. (x에 접근 가능)
2. change 메서드에서 매개변수 d를 이용하여 x의 값을 1000으로 변경한다.
3. change 메서드가 종료되면서 매개변수 d는 스택에서 제거된다.

change 메서드의 매개변수를 **참조형**으로 선언했기 때문에, x의 값이 아닌 주소가 매개변수 d에 복사되었다. 그렇기 때문에 main 메서드의 참조변수 d와 change 메서드의 참조변수 d는 같은 객체를 가리키게 되어 변경이 가능해진 것이다.

<br>

<br>

# 6. 클래스 메서드와 인스턴스 메서드

변수에서 그랬던 것과 같이, 메서드 앞에 `static` 키워드가 붙어 있으면 클래스 메서드, 붙어 있지 않으면 인스턴스 메서드이다.

- `클래스 메서드` : 인스턴스와 관계 없는(인스턴스 변수나 인스턴스 메서드를 사용하지 않는) 메서드
  - 물론 인스턴스 변수를 사용하지 않는다고 해서 반드시 클래스 메서드로 정의해야하는 것은 아니지만 특별한 이유가 없는 한 이렇게 하는 것이 일반적이다.
- `인스턴스 메서드` : 인스턴스 변수와 관련된 작업을 하는, 즉 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드

클래스 메서드도 클래스 변수처럼 객체를 생성하지 않고도 `클래스 이름.메서드 이름(매개변수)`의 형식으로 호출이 가능하다. 반면에 인스턴스 메서드는 반드시 객체를 생성해야만 호출할 수 있다. 

<br>

## 클래스 메서드의 특징

**1. 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통적으로 사용하는 것에 `static`을 붙인다.**

생성되는 각 인스턴스는 서로 독립적이기 때문에 각 인스턴스 변수는 서로 다른 값을 유지한다. 그러나 모든 인스턴스에서 같은 값이 유지되어야 하는 변수는 `static`을 붙여 클래스 변수로 정의해야 한다.

**2. 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다.**

`static`이 붙은 변수(클래스 변수)는 클래스가 메모리에 올라갈 때 이미 자동적으로 생성되기 때문에 인스턴스를 생성하지 않아도 `클래스 이름.메서드 이름`의 형식으로 사용이 가능하다.

**3. 클래스 메서드는 인스턴스 변수를 사용할 수 없다.**

클래스 메서드는 인스턴스의 생성 없이 호출이 가능하기 때문에 호출되었을 때 인스턴스가 존재하지 않을 수도 있다. 그렇기 때문에 클래스 메서드에서 인스턴스 변수의 사용을 금지한다.

(반면에 인스턴스 변수나 인스턴스 메서드에서는 `static`이 붙은 멤버들을 사용하는 것이 언제나 가능하다. 인스턴스 변수가 존재한다는 것은 static 변수가 이미 메모리에 존재한다는 것을 의미하기 때문이다.)

**4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, `static`을 붙이는 것을 고려한다.**

인스턴스 메서드는 실행 시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더 걸린다. 반면에 클래스 메서드는 호출 시간이 짧고 성능이 향상된다. 그렇기 때문에 인스턴스 변수를 필요로 하지 않는다면 `static` 키워드를 붙여 클래스 메서드로 선언하는 쪽이 바람직하다.

<br>

<br>

# 7. 클래스 멤버와 인스턴스 멤버간의 참조와 호출

같은 클래스에 속한 멤버(변수 + 메서드)들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하다. 단, 클래스 멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야한다. 왜 그럴까?

그 이유는 **인스턴스 멤버가 존재하는 시점에는 클래스 멤버도 항상 존재하지만, 클래스 멤버가 존재하는 시점에는 인스턴스 멤버가 존재하지 않을 수도 있기 때문이다.** 

## 같은 클래스 내의 인스턴스 메서드와 static 메서드 간의 호출

<script src="https://gist.github.com/1eejisoo/33105c5503de155914bffb43d5f47ccc.js"></script>

같은 클래스 내의 메서드는 서로 객체의 생성이나 참조변수 없이 직접 호출이 가능하지만 static 메서드는 인스턴스를 호출할 수 없다. 때문에 **line11**에서 아래와 같은 에러가 난다. 

<img width="766" alt="스크린샷 2022-11-30 오후 8 50 53" src="https://user-images.githubusercontent.com/93996283/204789118-ced9578d-8b59-4520-a15d-ab70cc70fbec.png">

<br>

## 같은 클래스 내의 인스턴스 변수와 static 메서드 간의 호출

<script src="https://gist.github.com/1eejisoo/c85dc18598eaba10a1f31adcc29b37df.js"></script>

마찬가지로 **line 11**에서 아래와 같은 에러가 난다. 인스턴스 메서드에서는 인스턴스 변수를 사용할 수 있지만, static 메서드에서는 인스턴스 변수를 사용할 수 없다.

<img width="731" alt="스크린샷 2022-11-30 오후 9 01 21" src="https://user-images.githubusercontent.com/93996283/204791052-2d8bc6af-05ba-4ae7-8b05-9ad2f8699303.png">

<br>

그러나 실제로는 같은 클래스 내에서 클래스 멤버가 인스턴스 멤버를 참조 또는 호출해야하는 경우는 드물다. 만일 그런 경우가 발생한다면 인스턴스 메서드로 작성해야할 메서드를 클래스 메서드로 작성한 것은 아닌지 한 번 더 생각해봐야 한다.

<br>

# 각주

[^1]: 수학의 함수와 달리 메서드는 입력값 또는 출력값(결과값)이 없을 수도 있으며, 심지어는 입력값과 출력값이 모두 없을 수도 있다.
