---
title: "[알고리즘] 다이나믹 프로그래밍"
categories:
  - algorithm
toc_label: "목차"
toc: true
toc_sticky: true
date: 2023-01-02
---

<details><summary><b>reference</b></summary>
&lt;이것이 취업을 위한 코딩테스트다 with 파이썬&gt;을 학습하며 정리한 내용입니다.
</details>

<br>

# 다이나믹 프로그래밍

---

- **메모리를 적절히 사용하여 수행 시간 효율성울 비약적으로 향상시키는 방법**
- <u>이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장</u>하여 다시 계산하지 않도록 한다.
- 다이나믹 프로그래밍의 구현은 일반적으로 두 가지 방식(Top-Down과 Bottom-Up 또는 하향식과 상향식)으로 구성된다.
- **동적 계획법**이라고도 부른다.

## 다이나믹 프로그래밍의 조건

{: .notice--info}

**1. 최적 부분 구조 (Optimal Substructure)** <br>&nbsp;&nbsp;&nbsp;큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다. <br> <br>**2. 중복되는 부분 문제 (Overlapping Subproblem)** <br>&nbsp;&nbsp;&nbsp;동일한 작은 문제를 반복적으로 해결해야 한다.

## Top-Down 방식

- **재귀 함수**를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법을 말한다.

- 큰 문제를 해결하기 위해 작은 문제를 호출한다.

## Bottom-Up 방식

- 단순히 **반복문**을 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법을 말한다.
- 작은 문제부터 차근차근 답을 도출한다.

## Top-Down VS Bottom-Up

- **Top-Down**방식은 **하향식**이라고도 하며, **Bottom-Up** 방식은 **상향식**이라고도 한다.
- 다이나믹 프로그래밍의 전형적인 형태는 **Bottom-Up** 방식이다.
  - 결과 저장용 리스트는 **DP 테이블**이라고 부른다.
- 가능하다면 Top-Down 방식 보다는 **Bottom-Up** 방식으로 구현하는 것을 권장한다.
  - 시스템 상 재귀 함수의 스택 크기가 한정되어 있을 수도 있기 때문이다.

## cf) 메모이제이션(Memoization)

- 다이나믹 프로그래밍을 구현하는 방법 중 하나로 **Top-Down(하향식)** 방식에 해당된다.
- <u>한 번 계산한 결과를 메모리 공간에 메모</u>하는 기법
  - 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져온다.
  - 값을 기록해 놓는다는 점에서 **캐싱(Caching)**이라고도 한다.
- 엄밀히 말하자면 메모이제이션은 <u>이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념</u>을 의미한다.
  - 따라서 메모이제이션은 다이나믹 프로그래밍에 국한된 개념은 아니다.
  - 한 번 계산된 결과를 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있다.

<br>

<br>

# 다이나믹 프로그래밍 예시 - 피보나치 수열

---

## 재귀함수로 구현한 피보나치 수열의 문제점

보통 피보나치 수열 하면 재귀함수를 이용해 코드를 작성하는 것을 떠올릴 것이다. 

그러나 n이 커지면 커질수록 수행 시간이 기하급수적으로 늘어나게 된다. 일반적으로 피보나치 수열의 시간 복잡도는 𝑶(2^n)의 지수 시간이 소요된다고 표현한다. 예를 들어 f(30)은 약 10억 가량의 연산을 수행해야 한다.

f(6)일 때의 호출 과정을 아래 그림으로 확인해보자.

<img width="991" alt="스크린샷 2023-01-02 오후 9 07 02" src="https://user-images.githubusercontent.com/93996283/210229113-ab511396-9436-4ca3-8bed-6ed18ae7312a.png">

f(2)일 때가 여러 번 호출되는 것을 확인할 수 있다. 이러한 비효율적 문제를 다이나믹 프로그래밍을 사용하면 효율적으로 해결할 수 있다. 

<br>

## 다이나믹 프로그래밍으로 구현한 피보나치 수열

### Top-Down 방식 - 메모이제이션

- **실행결과**: 12586269025

<script src="https://gist.github.com/1eejisoo/1d402c99ca470900f048190d8547c09b.js"></script>

<br>

### Bottom-Up 방식

- **실행결과**: 12586269025

<script src="https://gist.github.com/1eejisoo/4fe05111824c33b9807c1a5596c4dcca.js"></script>

<br>

### 시간 복잡도

다이나믹 프로그래밍을 적용했을 때의 피보나치 수열 알고리즘의 시간 복잡도는 𝑶(𝑵)이다. 아래 그림을 살펴보자.

<img width="984" alt="스크린샷 2023-01-02 오후 9 22 59" src="https://user-images.githubusercontent.com/93996283/210230800-b2219435-3bed-4fdc-a780-0a9f0b85b5fd.png">

f(1)을 구한 다음 그 값이 f(2)를 푸는 데 사용되고, 또 f(2)의 값은 f(3)을 푸는 데 사용된다. 위의 그림에서는 칠해진 부분만이 연산에 사용된다. 즉, <u>한 번 구한 결과는 다시 구해지지 않는다.</u>

<br>

**호출되는 함수를 확인하기 위한 코드**

<script src="https://gist.github.com/1eejisoo/207fd785040347e77abeeebd09dfd81a.js"></script>

**실행결과**

{: .notice--primary}

f(6) f(5) f(4) f(3) f(2) f(1) f(2) f(3) f(4) 

n = 6일 때 함수는 총 6번 호출되는 것을 확인할 수 있다.

<br>

<br>

# 다이나믹 프로그래밍 문제에 접근하는 방법

---

- 우선 주어진 문제가 **다이나믹 프로그래밍 유형임을 파악하는 것**이 중요하다.
  - 가장 먼저 그리디, 구현, 완전 탐색 등의 아이디어로 문제를 해결할 수 있는지 검토한다. 
  - 만약 다른 방법이 떠오르지 않는다면 다이나믹 프로그래밍을 고려해본다.
- 일단 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤에 (Top-Down) 작은 문제에서 구한 답 큰 문제에서 그대로 사용될 수 있으면 코드를 개선하는 방법으로 사용할 수 있다.
- 완전 탐색 알고리즘으로 접근했을 때 시간이 매우 오래 걸리면 다이나믹 프로그래밍을 적용할 수 있는지 해결하고자 하는 부분 문제들의 중복 여부를 확인해보자.
