---
title: "[알고리즘] 정렬"
categories:
  - algorithm
tags:
  - 알고리즘
  - 정렬
toc_label: "목차"
toc: true
toc_sticky: true
date: 2022-12-13 03:00:00
---

<details><summary><b>reference</b></summary>
&lt;이것이 취업을 위한 코딩테스트다 with 파이썬&gt;을 학습하며 정리한 내용입니다.
</details>
<b>

# 정렬이란?

- <b><u>데이터를 특정한 기준에 따라 순서대로 나열하는 것</u></b>을 말하며 일반적으로 문제 상황에 따라서 적절한 정렬 알고리즘이 사용된다.

<br>

---

# 선택 정렬

- 처리되지 않은 데이터 중에서 **가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것을 반복**한다.

- 선택 정렬은 가장 원시적인 방법으로 매번 '가장 작은 것을 선택' 한다. 

## 선택 정렬 구현코드 

<script src="https://gist.github.com/1eejisoo/942607372d2cc3a86e151c0fd18d986b.js"></script>

**실행 결과**

```
0 1 2 3 4 5 6 7 8 9 
```



## 시간 복잡도

선택 정렬은 N번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 한다. 구현 방식에 따라서 사소한 오차는 있을 수 있지만, 전체 연산 횟수는 아래와 같다.

> N + (N - 1) + (N - 2) + ... + 2

이는 (N^2 + N - 2) / 2로 표현할 수 있는데, 빅오 표기법에 따라서 𝑶(𝑵²) 라고 작성한다.

- 직관적으로 이해하자면 소스코드 상으로 간단한 형태의 2중 반복문이 사용되었기 때문이라고 이해할 수 있다.  (2중 반목문이 사용되었다고 해서 항상 𝑶(𝑵²)의 시간 복잡도는 갖지는 않는다.)

> **효율성 면에서의 선택정렬**
>
> 만약 정렬해야 할 데이터의 개수가 100배 늘어난다면, 이론적으로 수행 시간은 10,000배로 늘어나게 된다. 이는 매우 비효율적이며, 실제로 선택 정렬은 기본 정렬 라이브러리를 포함해 다른 정렬 알고리즘에 비해 비효율적인 알고리즘이다.

<br>

---

# 삽입 정렬

- 처리되지 않은 데이터를 하나씩 골라 **적절한 위치에 삽입**한다.
- 특정 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다.
  - 그렇기 때문에 첫 번째 데이터는 그 자체로 정렬되어 있다고 판단하여, 두 번째 데이터부터 시작한다.
- 선택 정렬과 비교했을 때 더 효율적으로 동작한다.

## 삽입 정렬 구현코드

<script src="https://gist.github.com/1eejisoo/43ae0294038fcc66b4530a1ce2134a04.js"></script>

**실행 결과**

```
0 1 2 3 4 5 6 7 8 9 
```



## 시간 복잡도

삽입 정렬의 시간 복잡도는 𝑶(𝑵²) 이다. 

직관적으로 이해하자면 선택 정렬과 마찬가지로 반복문이 2번 중첩되어 사용되었기 때문이라고 이해할 수 있다. 

그러나 <b><u>현재 리스트의 데이터가 거의 정렬되어 있는 상태</u></b>라면 매우 빠르게 동작하기 때문에, 최선의 경우에는 𝑶(𝑵)의 시간 복잡도를 갖는다. 예를 들어 { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }의 데이터를 가진 배열에 삽입 정렬을 수행하면 𝑶(𝑵)의 시간 복잡도를 갖는다. 

다음으로 설명될 퀵 정렬 알고리즘과 비교했을 때, 보통은 삽입 정렬이 비효율적이나 정렬이 거의 되어 있는 상황에서는 퀵 정렬 알고리즘보다 더 강력하다.

<br>

---

# 퀵 정렬

- <u>기준 데이터를 설정</u>하고, 그 **기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법**이다.
  - 만약 두 값이 서로 엇갈린 경우에는 **'작은 데이터'**와 **'피벗'**의 위치를 서로 변경한다.
- 일반적인 상황에서 가장 많이 사용되며, 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘이다.
- 가장 기본적인 퀵 정렬은 **첫 번째 데이터를 기준 데이터(Pivot)**로 설정한다.

>  **분할(Divide)** 또는 **파티션(Partition)** 
>
>  피벗의 왼쪽에는 피벗보다 작은 데이터가 위치하고, 피벗의 오른쪽에는 피벗보다 큰 데이터가 위치하도록 하는 작업을 말한다. 

> **퀵 정렬의 종료 조건?**
>
> 퀵 정렬은 특정한 리스트에서 피벗을 설정하여 정렬을 수행한 이후에, 피벗을 기준으로 왼쪽 리스트와 오른쪽 리스트에서 각각 다시 정렬을 수행한다. 즉 **'재귀 함수'**와 동작 원리가 같다. 재귀 함수와 동작 원리가 같다면, 종료 조건도 있어야 할 것이다. 

퀵 정렬이 끝나는 조건은  <b><u>현재 리스트의 데이터 개수가 1개인 경우</u></b>이다.

## 퀵 정렬 구현코드

<script src="https://gist.github.com/1eejisoo/32de710f8da5d36da1d3664c3c49627d.js"></script>

**실행 결과**

```
0 1 2 3 4 5 6 7 8 9 
```



## 시간 복잡도

퀵 정렬의 평균 시간 복잡도는 𝑶(𝑵𝒍𝒐𝒈𝑵)이다. 

앞서 다루었던 선택 정렬, 삽입 정렬 알고리즘에 비해 매우 빠른 편이라는 것을 알 수 있다.

하지만 최악의 경우 𝑶(𝑵²)의 시간 복잡도를 갖는다. 아래의 예시를 살펴보자

```java
// 이미 정렬된 배열
int[] arr = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
```

첫 번째 원소를 피벗으로 삼을 때, 이미 정렬된 배열인 `arr`에 퀵 정렬을 수행하면 어떻게 될까?

피벗인 0을 기준으로 왼쪽에서부터 큰 데이터(= 1)는 찾을 수 있지만, 오른쪽에서부터 작은 데이터를 찾으면 결국 자기 자신(= 0)이 된다. 결국 피벗 값 자기 자신에서 자기 자신의 위치로 변경되기 때문에 분할이 이루어졌을 때, 피벗을 기준으로 왼쪽 부분은 존재하지 않고 오른쪽 부분만 존재하는 것과 동일해진다.

그런 다음 오른쪽 부분에 대해서 1을 피벗 값으로 설정한 후 퀵 정렬을 수행하게 되면, **매번 오른쪽 데이터만 남는 형태로 분할**이 이루어진다. 때문에 최악의 경우에는 분할 수행 횟수가 데이터의 개수(N)와 비례하고, 분할을 하기 위해서는 매번 선형 탐색을 수행해야되기 때문에 전체 시간 복잡도는 𝑶(𝑵²)가 된다.

<br>

---

# 계수 정렬

- 특정 조건이 부합할 때만 사용할 수 있지만 **매우 빠르게 동작하는 정렬 알고리즘**이다.

> **계수 정렬의 사용 조건?**
>
> - 계수 정렬은 **데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때** 사용 가능하다.
>
> - (가장 큰 데이터와 가장 작은 데이터의 차이 + 1) 만큼 리스트를 초기화해야하기 때문에 차이가 너무 크면 사용할 수 없다.

## 계수 정렬 구현코드

<script src="https://gist.github.com/1eejisoo/10ff30bd7478ae0f3aeec32da84dbd7a.js"></script>

**실행결과**

```
0 0 1 1 2 2 3 4 5 5 6 7 8 8 9 
```



## 시간 복잡도

데이터의 개수가 *N*, 데이터(양수) 중 최댓값이 *K*일 때, 최악의 경우에도 수행 시간 𝑶(𝑵+𝑲)를 보장한다.

사실상 현존하는 정렬 알고리즘 중에서 기수 정렬(Radix Sort)과 더불어 가장 빠르다고 볼 수 있다. 

## 공간 복잡도

공간 복잡도 역시 𝑶(𝑵+𝑲)이다. 

그러나 계수 정렬은 때에 따라서 심각한 비효율성을 초래할 수 있다. 예를 들어 데이터가 0과 999,999로 단 2개만 존재하는 상황에서도 리스트의 크기는 100만 개가 되어야 한다.

따라서 **동일한 값을 가지는 데이터가 여러 개 등장할 때 사용하는 것이 적합**하다. (ex. 성적)

<br>

---

# 정렬 알고리즘 비교하기

| 정렬 알고리즘 | 평균 시간 복잡도 | 공간 복잡도 | 특징                                                         |
| :-----------: | :--------------: | :---------: | :----------------------------------------------------------- |
|   선택 정렬   |      𝑶(𝑵²)       |    𝑶(𝑵)     | 아이디어가 매우 간단하다.                                    |
|   삽입 정렬   |      𝑶(𝑵²)       |    𝑶(𝑵)     | 데이터가 거의 정렬되어 있을 때는 가장 빠르다.                |
|    퀵 정렬    |     𝑶(𝑵𝒍𝒐𝒈𝑵)     |    𝑶(𝑵)     | 대부분의 경우에 가장 적합하며, 속도도 빠르다.                |
|   계수 정렬   |      𝑶(𝑵+𝑲)      |   𝑶(𝑵+𝑲)    | 데이터의 크기가 한정되어 있는 경우에만 사용이 가능하지만 매우 빠르게 동작한다. |

